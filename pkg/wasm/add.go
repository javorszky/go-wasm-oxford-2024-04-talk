package wasm

import (
	"context"
	_ "embed"
	"fmt"

	"github.com/pkg/errors"
)

// addWasm was generated by the following:
//
//	cd testdata; tinygo build -o add.wasm -target=wasi add.go
//
//go:embed testdata/add/add.wasm
var addWasm []byte

func (r *Runner) execAdd(ctx context.Context) ([]byte, error) {
	// Instantiate the guest Wasm into the same runtime. It exports the `add`
	// function, implemented in WebAssembly.
	mod, err := r.r.Instantiate(ctx, addWasm)
	if err != nil {
		return nil, fmt.Errorf("failed to instantiate module: %v", err)
	}

	params := ctx.Value(ContextKey)
	if params == nil {
		return nil, fmt.Errorf("failed to instantiate module due to empty context")
	}

	// we need to type infer this so we know it's a []uint64 instead of "any".
	paramsParsed, ok := params.([]uint64)
	if !ok {
		return nil, fmt.Errorf("failed to instantiate module due to bad context type")
	}

	// Call the `add` function and print the results to the console.
	add := mod.ExportedFunction("add")

	// this way of calling an exported function only works for numerical types. Wasm is a bytes-in-bytes-out language.
	results, err := add.Call(ctx, paramsParsed...)
	if err != nil {
		return nil, errors.Wrap(err, "failed to call add")
	}

	return []byte(fmt.Sprintf("%d", results[0])), nil
}
